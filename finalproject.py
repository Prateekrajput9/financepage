import pandas as pd


btc_usdt_data = pd.read_csv('Binance_BTCUSDT_d.csv')

#dTE WALE COULUMN KA DATATYPE DATETIME KR DIYA
btc_usdt_data['Date'] = pd.to_datetime(btc_usdt_data['Date'], format='%d-%m-%Y')

# Set the 'Date' column as the index
btc_usdt_data.set_index('Date', inplace=True)

# SABKA DATATYPE NUMERIC KR DIYA
numeric_columns = ['Open', 'High', 'Low', 'Close', 'Volume BTC', 'Volume USDT', 'tradecount']
btc_usdt_data[numeric_columns] = btc_usdt_data[numeric_columns].apply(pd.to_numeric)


print(btc_usdt_data.head())

                Open      High       Low     Close   Volume BTC   Volume USDT  \
Date                                                                            
2024-06-11  69540.00  69590.01  66051.00  67314.24  41436.01588  2.793799e+09   
2024-06-10  69648.15  70195.94  69172.29  69540.00  17122.66941  1.192467e+09   
2024-06-09  69310.46  69857.14  69130.24  69648.14   9890.56709  6.873447e+08   
2024-06-08  69355.60  69582.20  69168.02  69310.46   9773.82967  6.782674e+08   
2024-06-07  70799.06  71997.02  68420.00  69355.60  35598.45045  2.507251e+09   

            tradecount  
Date                    
2024-06-11     1782415  
2024-06-10      936731  
2024-06-09      575583  
2024-06-08      714103  
2024-06-07     1516415 
btc_usdt_data['return'] = btc_usdt_data['Close'].pct_change()
btc_usdt_data['volatility'] = btc_usdt_data['Close'].rolling(window=10).std()
btc_usdt_data['momentum'] = btc_usdt_data['Close'].diff(3)
btc_usdt_data['SMA_10'] = btc_usdt_data['Close'].rolling(window=10).mean()
btc_usdt_data['LMA_50'] = btc_usdt_data['Close'].rolling(window=50).mean()
for lag in range(1, 6):
    btc_usdt_data[f'lag_{lag}'] = btc_usdt_data['Close'].shift(lag)

# Drop rows with NaN values (generated by lagging and moving averages)
btc_usdt_data.dropna(inplace=True)

# FINAL DATA
print(btc_usdt_data.head())

               Open      High       Low     Close   Volume BTC   Volume USDT  \
Date                                                                            
2024-04-23  66819.32  67183.01  65765.81  66414.00  22599.90004  1.502140e+09   
2024-04-22  64941.15  67232.35  64500.00  66819.32  31397.99371  2.071690e+09   
2024-04-21  64940.58  65695.56  64237.50  64941.15  19316.42152  1.254397e+09   
2024-04-20  63818.01  65419.00  63090.07  64940.59  23137.42975  1.486950e+09   
2024-04-19  63470.09  65450.00  59600.01  63818.01  69774.30271  4.419893e+09   

            tradecount    return   volatility  momentum     SMA_10  \
Date                                                                 
2024-04-23     1433915  0.033044  2559.052417   2643.99  62751.612   
2024-04-22     1816591  0.006103  2490.910988   2320.98  63527.483   
2024-04-21     1390153 -0.028108  1727.684305    651.56  64185.101   
2024-04-20     1376712 -0.000009  1214.305310  -1473.41  64611.960   
2024-04-19     2828284 -0.017286  1217.671112  -3001.31  64607.161   

                LMA_50     lag_1     lag_2     lag_3     lag_4     lag_5  
Date                                                                      
2024-04-23  65914.8708  64289.59  64498.34  63770.01  63461.98  63118.62  
2024-04-22  65904.9724  66414.00  64289.59  64498.34  63770.01  63461.98  
2024-04-21  65812.9954  66819.32  66414.00  64289.59  64498.34  63770.01  
2024-04-20  65718.8444  64941.15  66819.32  66414.00  64289.59  64498.34  
2024-04-19  65608.9954  64940.59  64941.15  66819.32  66414.00  64289.59  


from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# TARGET VARIABLE :1 FOR BUYING CONDITION AND 0 FOR SELLING CONDITION
btc_usdt_data['target'] = (btc_usdt_data['Close'].shift(-1) > btc_usdt_data['Close']).astype(int)

# FEATURES FOR ML
features = ['Open', 'High', 'Low', 'Close', 'Volume BTC', 'volatility', 'momentum', 'SMA_10', 'LMA_50'] + [f'lag_{lag}' for lag in range(1, 6)]
X = btc_usdt_data[features]
y = btc_usdt_data['target']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# USING RandomForestClassifier MODEL AND TRAINING IT WITH MY DATA 
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
# Calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.2f}')



# Backtesting
X_test['predicted_signal'] = y_pred
X_test['close'] = btc_usdt_data['Close'].loc[X_test.index]

# Initialize variables for tracking performance metrics
initial_capital = 10000
capital = initial_capital
position = 0
transaction_cost = 0.001  # 0.10 percent per transaction
portfolio_values = []

# SIMPLE strategy IS KI WHEN TARGET =1 HOGA THAN BUY AND SELL WHEN TARGET 0 HOGA
for i in range(len(X_test) - 1):
    if X_test['predicted_signal'].iloc[i] == 1:  # Buy signal
        if position == 0:
            position = capital / X_test['close'].iloc[i]
            capital -= position * X_test['close'].iloc[i] * transaction_cost
    elif X_test['predicted_signal'].iloc[i] == 0:  # Sell signal
        if position > 0:
            capital += position * X_test['close'].iloc[i]
            capital -= position * X_test['close'].iloc[i] * transaction_cost
            position = 0
    portfolio_values.append(capital + position * X_test['close'].iloc[i])

# Calculate the final portfolio value
final_value = capital + position * X_test['close'].iloc[-1]
portfolio_values.append(final_value)
print(f'Final Portfolio Value: ${final_value:.2f}')

# Calculate daily returns
portfolio_values = np.array(portfolio_values)
daily_returns = np.diff(portfolio_values) / portfolio_values[:-1]

# Calculate cumulative returns
cumulative_returns = portfolio_values[-1] / portfolio_values[0] - 1
print(f'Cumulative Returns: {cumulative_returns:.2f}')

# Calculate annualized returns ABHI VALUE ME KUCH ERROR HO RHI H BAAD ME SAHI KARUNGA
annualized_returns = np.mean(daily_returns) * 252
print(f'Annualized Returns: {annualized_returns:.2f}')

# Calculate annualized volatility ABHI VALUE ME KUCH ERROR HO RHI H BAAD ME SAHI KARUNGA
annualized_volatility = np.std(daily_returns) * np.sqrt(252)
print(f'Annualized Volatility: {annualized_volatility:.2f}')

# Calculate Sharpe ratio (assuming risk-free rate is 0)
sharpe_ratio = annualized_returns / annualized_volatility
print(f'Sharpe Ratio: {sharpe_ratio:.2f}')

# Calculate drawdowns
running_max = np.maximum.accumulate(portfolio_values)
drawdowns = (running_max - portfolio_values) / running_max
max_drawdown = np.max(drawdowns)
print(f'Max Drawdown: {max_drawdown:.2f}')
#BACKTESTING RESULT OUTPUT:
Final Portfolio Value: $20352.00
Cumulative Returns: 10184.00
Annualized Returns: 36.07
Annualized Volatility: 5.47  
Sharpe Ratio: 6.59
Max Drawdown: 0.09
